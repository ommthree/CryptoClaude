#pragma once

#include <string>
#include <vector>
#include <map>
#include <memory>
#include <chrono>
#include "PerformanceAttributionEngine.h"
#include "TechnicalIndicators.h"
#include "../Database/DatabaseManager.h"

namespace CryptoClaude {
namespace Analytics {

/**
 * Market data point for backtesting
 */
struct MarketDataPoint {
    std::chrono::system_clock::time_point timestamp;
    std::string symbol;
    double open;
    double high;
    double low;
    double close;
    double volume;

    MarketDataPoint() = default;
    MarketDataPoint(const std::chrono::system_clock::time_point& ts,
                   const std::string& sym, double o, double h, double l, double c, double v)
        : timestamp(ts), symbol(sym), open(o), high(h), low(l), close(c), volume(v) {}
};

/**
 * Trading signal generated by strategy
 */
struct TradingSignal {
    std::chrono::system_clock::time_point timestamp;
    std::string symbol;
    std::string action; // "BUY", "SELL", "HOLD"
    double strength; // Signal strength (0.0 to 1.0)
    double suggested_position_size; // Percentage of portfolio
    std::map<std::string, double> indicators; // Technical indicator values

    TradingSignal() = default;
    TradingSignal(const std::chrono::system_clock::time_point& ts, const std::string& sym,
                 const std::string& act, double str, double pos_size)
        : timestamp(ts), symbol(sym), action(act), strength(str), suggested_position_size(pos_size) {}
};

/**
 * Backtest trade execution record
 */
struct BacktestTrade {
    std::string trade_id;
    std::chrono::system_clock::time_point entry_time;
    std::chrono::system_clock::time_point exit_time;
    std::string symbol;
    std::string direction; // "LONG", "SHORT"
    double entry_price;
    double exit_price;
    double position_size; // Number of units
    double pnl; // Profit/Loss
    double fees; // Trading fees
    std::string exit_reason; // "TAKE_PROFIT", "STOP_LOSS", "SIGNAL", "TIMEOUT"

    BacktestTrade() = default;
};

/**
 * Backtesting period performance metrics
 */
struct BacktestResults {
    std::chrono::system_clock::time_point start_date;
    std::chrono::system_clock::time_point end_date;

    // Returns and Risk
    double total_return;
    double annualized_return;
    double volatility;
    double sharpe_ratio;
    double sortino_ratio;
    double calmar_ratio;

    // Drawdown Analysis
    double max_drawdown;
    double max_drawdown_duration_days;
    std::chrono::system_clock::time_point max_drawdown_start;
    std::chrono::system_clock::time_point max_drawdown_end;

    // Trade Analysis
    int total_trades;
    int winning_trades;
    int losing_trades;
    double win_rate;
    double average_win;
    double average_loss;
    double profit_factor; // Gross profit / Gross loss

    // Portfolio Metrics
    double starting_capital;
    double ending_capital;
    double peak_capital;
    std::vector<double> equity_curve;
    std::vector<std::chrono::system_clock::time_point> equity_timestamps;

    BacktestResults() = default;
};

/**
 * Walk-forward analysis parameters
 */
struct WalkForwardConfig {
    int training_period_days;
    int testing_period_days;
    int step_size_days;
    std::map<std::string, std::vector<double>> parameter_ranges;

    WalkForwardConfig() : training_period_days(180), testing_period_days(30), step_size_days(30) {}
};

/**
 * Advanced backtesting engine for cryptocurrency trading strategies
 * Supports historical data validation, walk-forward analysis, and comprehensive performance metrics
 */
class BacktestingEngine {
public:
    BacktestingEngine();
    ~BacktestingEngine() = default;

    // Initialization and Configuration
    bool initialize(std::shared_ptr<Database::DatabaseManager> db_manager);
    void setSlippageModel(double fixed_slippage_bps = 10.0);
    void setCommissionModel(double commission_bps = 25.0);
    void setStartingCapital(double capital);

    // Historical Data Management
    bool loadHistoricalData(const std::string& symbol,
                           const std::chrono::system_clock::time_point& start_date,
                           const std::chrono::system_clock::time_point& end_date);
    bool loadHistoricalDataFromDatabase(const std::vector<std::string>& symbols,
                                       const std::chrono::system_clock::time_point& start_date,
                                       const std::chrono::system_clock::time_point& end_date);

    // Strategy Testing
    BacktestResults runBacktest(const std::string& strategy_name,
                               const std::chrono::system_clock::time_point& start_date,
                               const std::chrono::system_clock::time_point& end_date);

    // Walk-Forward Analysis
    std::vector<BacktestResults> runWalkForwardAnalysis(const std::string& strategy_name,
                                                       const WalkForwardConfig& config,
                                                       const std::chrono::system_clock::time_point& start_date,
                                                       const std::chrono::system_clock::time_point& end_date);

    // Strategy Implementation Interface
    virtual std::vector<TradingSignal> generateSignals(const std::vector<MarketDataPoint>& market_data,
                                                       const std::chrono::system_clock::time_point& current_time);

    // Performance Analysis
    BacktestResults calculatePerformanceMetrics(const std::vector<BacktestTrade>& trades,
                                               const std::vector<double>& equity_curve,
                                               const std::vector<std::chrono::system_clock::time_point>& timestamps);

    // Risk Analysis
    double calculateValueAtRisk(const std::vector<double>& returns, double confidence_level = 0.05);
    double calculateConditionalVaR(const std::vector<double>& returns, double confidence_level = 0.05);
    std::vector<double> calculateRollingDrawdown(const std::vector<double>& equity_curve);

    // Stress Testing
    BacktestResults stressTestStrategy(const std::string& strategy_name,
                                      const std::string& stress_scenario); // "BULL", "BEAR", "HIGH_VOLATILITY", "FLASH_CRASH"

    // Reporting and Persistence
    bool saveBacktestResults(const std::string& strategy_name, const BacktestResults& results);
    std::vector<BacktestResults> loadBacktestHistory(const std::string& strategy_name);
    std::string generatePerformanceReport(const BacktestResults& results);

    // Data Quality and Validation
    bool validateHistoricalData(const std::vector<MarketDataPoint>& data);
    void fillMissingData(std::vector<MarketDataPoint>& data);

private:
    std::shared_ptr<Database::DatabaseManager> db_manager_;
    std::unique_ptr<TechnicalIndicators> indicators_;
    std::unique_ptr<PerformanceAttributionEngine> performance_engine_;

    // Trading Configuration
    double starting_capital_;
    double fixed_slippage_bps_;
    double commission_bps_;

    // Historical Data Storage
    std::map<std::string, std::vector<MarketDataPoint>> historical_data_;

    // Execution Engine
    std::vector<BacktestTrade> executeStrategy(const std::vector<TradingSignal>& signals,
                                              const std::vector<MarketDataPoint>& market_data);

    // Portfolio Management
    double calculatePositionSize(const TradingSignal& signal, double current_capital, double current_price);
    double applySlippageAndFees(double price, double volume, const std::string& action);

    // Market Data Utilities
    MarketDataPoint interpolatePrice(const std::chrono::system_clock::time_point& timestamp,
                                   const std::vector<MarketDataPoint>& data);
    std::vector<MarketDataPoint> getMarketDataForPeriod(const std::string& symbol,
                                                       const std::chrono::system_clock::time_point& start,
                                                       const std::chrono::system_clock::time_point& end);

    // Statistical Analysis
    double calculateSharpeRatio(const std::vector<double>& returns, double risk_free_rate = 0.02);
    double calculateSortinoRatio(const std::vector<double>& returns, double target_return = 0.0);
    double calculateCalmarRatio(double annualized_return, double max_drawdown);
    std::vector<double> calculateReturns(const std::vector<double>& equity_curve);

    // Scenario Generation for Stress Testing
    std::vector<MarketDataPoint> generateStressScenario(const std::string& scenario_type,
                                                       const std::vector<MarketDataPoint>& base_data);

    // Database Operations
    bool createBacktestTables();
    bool insertMarketData(const std::vector<MarketDataPoint>& data);
    bool insertBacktestResults(const std::string& strategy_name, const BacktestResults& results);

    // Utility Functions
    std::string timePointToString(const std::chrono::system_clock::time_point& tp);
    std::chrono::system_clock::time_point stringToTimePoint(const std::string& str);
};

}} // namespace CryptoClaude::Analytics